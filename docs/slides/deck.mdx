import { Appear, Head, Notes, Image } from 'mdx-deck';
import Split from './src/Split';
import { syntaxHighlighter as SyntaxHighlighter } from 'mdx-deck/themes';
export { theme } from './theme'

<Head>
  <title>BDD workshop</title>
</Head>

# Multi-layer Outside-in BDD
## Behaviour Driven Design <br/>for modern Rails apps

---

## A note on these slides

1. simplified version of slides from actual workshop
1. use [MDX-deck](https://github.com/jxnblk/mdx-deck)
1. raw MDX deck can be viewed in git repo
    * [github docs/slides/deck.mdx](https://github.com/failure-driven/bdd-workshop-app/blob/master/docs/slides/deck.mdx)
1. to see speaker notes **OPTION-p** (`⌥ p`) on mac

<Notes>

* no notes on this slide

</Notes>

---

## Install - code

* git clone git@github.com/failure-driven/bdd-workshop-app.git
* Ruby 2.6.2, Node 10.15.3, PostgreSQL, Chrome
```sh
bundle install && yarn install
bin/rails db:create db:migrate
make
bin/rails server
```

<Notes>

* or look at the repo http://bit.ly/railsconf2019-bdd

</Notes>

---

## Install - Kahoot

* https://kahoot.com/mobile-app/
* Or directly https://kahoot.it/

<Notes>

* pre workshop kahoot
* https://create.kahoot.it/share/bdd-workshop-icebreaker/5aed0b32-91d3-4745-83f5-3cd0089b93cb

</Notes>

---

## Fresho

<Image
  style={{ width: '400px', height: '400px' }}
  src="images/fresho_logo_green.svg" />

<Notes>

* The way we work at Fresho
* 8 developers, full stack, full pipeline
    * No QA
    * No ops
* Devs do
    * Business analysis - 2am market visits
    * Solution design
    * Frontend, backend, infrastructure, test frameworks
* Pairing, trunk based development which is agile and iterative
* 100% test first
* Each piece of code is tested in 6 or 7 different ways before it’s written
* A well maintained automated test suite will ultimately save you time
* Manual tests DO NOT SCALE

</Notes>

---

# Test Driven Design

<Appear>

<div>

* Red, Green, Refactor

</div>
<div>

* Design a loosely-coupled solution

</div>
<div>

* Test code implementation of an isolated unit

</div>

</Appear>

<Notes>

* When people think of testing they often think of TDD
* Test Driven Development
* or (more correctly) Test Driven Design
* TDD often refers to test driving implementation of isolated units
    * Red Green Refactor
    * Write a test
    * See it fail
    * Write the simplest implementation to make the test pass
    * And iterate
* TDD is a great way to design simple, loosely coupled solutions at a detailed low level
* It’s all about the code implementation of single isolated units
* But the style of testing we’re primarily interested today in (you guessed it!) BDD - Behaviour Driven Design

</Notes>

---

# Behaviour Driven Design

<Appear>

<div>

* Enough is enough

</div>
<div>

* Deliver stakeholder value

</div>
<div>

* Test behaviour across many units

</div>

</Appear>

<Notes>

* In contrast, BDD is about testing behaviour, NOT implementation
* According to the RSpec book, there are 3 key principles of BDD
* Enough is enough
    * Working towards stakeholder expectations, we should avoid doing more than we need to
    * Build the minimum feature
    * Get feedback from users
    * Build according to their needs
* Deliver stakeholder value
    * There are multiple stakeholders - ie shareholders, product owner, also admins and users
    * Software should be about delivering demonstrable value to them.
* BDD is all about behavior across many units
    * The idea being that isolated units which are tested on their own you may have 100% code coverage
    * But if a number of those units are expected to work together, your isolated tests may not be enough.

Let’s take a look at a 100% unit tested, behavioural failure

</Notes>

---

<Image
  style={{ width: '40vw', height: '70vh' }}
  src="images/automated-door-no-integration.gif"/>

<Notes>

* Can you see what’s going on here?
* A gate with a sensor, which seems to work correctly
* And a door with a sensor, which also seems to work correctly
* But where’s the person walking through the doors?!
* The problem here is that the two of these together don’t behave the way you would expect them to!

</Notes>

---

# TODO complete notes

---

## Modules

1. When Then steps
1. Page Fragments
1. Flows and Mechanics
1. Flakys
1. Drive new functionality through all the layers
1. How your tests will fail with refactors

---

# Modern rails app

- React SPA in places
- Admin and other rails views
- Rails backend as API
- Active record to DB
- dependency on external services

<Notes>
  <ul>
    <li>what it is</li>
  </ul>
</Notes>

---

# Tranditional view of testing

[Pyramid]

- UI tests
- Service layer Integration testing
- Traditional unit testing

<Notes>
  <ul>
    <li>happy case at the top</li>
    <li>integration testing</li>
    <li>unit as "isolated" unit</li>
    <li>number of tests at each layer</li>
  </ul>
</Notes>

---

# BDD
_Behaviour Driven Development_

<Notes>
  <ul>
    <li>test behaviour not implementation</li>
  </ul>
</Notes>

---

<Image
  style={{ width: '40vw', height: '70vh' }}
  src="https://cdn-images-1.medium.com/max/1600/1*SLmk-xp-dv7aS8XLabqlwA.gif"/>

<br />

<div style={{ fontSize: '0.7em' }}>
  https://medium.com/@Cyrdup/unit-testing-youre-doing-it-wrong-407a07692989
</div>

<Notes>
  <ul>
    <li>you want your code to have a use</li>
    <li>unit testing in isolation does not always do the trick</li>
  </ul>
</Notes>

---

# Module 1
## When Then steps

---

# Traditional Testing Scenario

|           |                                      |             |
|:--------- |:-------------------------------------|:----------- |
| **Given** | IMAGE<br />nail and hammer raised         | **Arrange** |
| **When ** | IMAGE<br />hammer strikes nail            | **Act    ** |
| **Then ** | IMAGE<br />nail goes into timber          | **Assert ** |

<Notes>
  <ul>
    <li>made up of these state, GWT</li>
    <li>Good points</li>
    <li>Limitations</li>
    <ul>
      <li>assumes the given setup is accurate to the behaviour of your app</li>
      <li>not case in real life</li>
      <li>user behaviour is not a 1 shot</li>
      <li>number of actions</li>
      <li>often a number of actors</li>
    </ul>
  </ul>
</Notes>


---

# Given When Then steps

<WhenThenSteps />

---

# Drop the Given

* ~~Given~~
* When
* Then


* When
* Then


* When
* Then

<Notes>

  * and get there through When Then steps
  * transition errors
  * Given ties us to mocking implementation without testing it's integration

</Notes>

---

# Example - signup to instagram

---

* **When** User of the internet visits instagram for a first time
* **Then** I am shown login and signup details

<div style={{ height: '60vh', width: '100%' }}>
{/* TODO: why do I need the width="30vw" below? */}
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/01_insta_visit.png')} />
</div>

---

* **When** I signup with
  * "Michael, saramic+2@gmail.com, saramic2020"
* **Then** I am encouraged to turn on notifcations

<div style={{ height: '60vh', width: '100%', display: 'flex' }}>
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/02_insta_fillin.png')} />
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/03a_insta_notifications.png')} />
</div>

---

* **When** I click _"Not Now"_
* **Then** I am on suggested people to follow page

<div style={{ height: '60vh', width: '100%', display: 'flex' }}>
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/03a_insta_notifications.png')} />
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/03_insta_recommend.png')} />
</div>

---

* **When** I follow instagram, mileycyrus, justinbieber
* **Then** It shows I am following them

<div style={{ height: '60vh', width: '100%', display: 'flex' }}>
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/03_insta_recommend.png')} />
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/04_insta_follow.png')} />
</div>

---

* **When** I click _"Get Started"_
* **Then** I am encouraged to add my phone and connect through Facebook
* **And** I have stories from people I follow
* **And** I have suggestions
* **And** I have a feed of posts from people I follow
* **And** I have search, explore, activity, profile links at the top

<div style={{ display: 'flex', maxWidth: '80vw', maxHeight: '40vw' }}>
<Image
  style={{ width: '25vw', maxHeight: '40vh' }}
  src={require('file-loader!./images/05_insta_get_started_link.png')} />

<Image
  style={{ width: '25vw', maxHeight: '40vh' }}
  src={require('file-loader!./images/06_insta_feed_page.png')} />

<Image
  style={{ width: '25vw', maxHeight: '40vh' }}
  src={require('file-loader!./images/07_insta_recommend_in_feed.png')} />
</div>

---

* **When** Email job is run
* **Then** User recieves the email
<div style={{ height: '60vh', width: '100%', display: 'flex' }}>
<Image
  width="80vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/08_insta_email.png')} />
</div>

---

* **When** click email link _"Confirm your email address"_
* **Then** User is taken to the site with alert _"You have successfully confirmed your email"_

<div style={{ height: '60vh', width: '100%', display: 'flex' }}>
<Image
  width="26vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/09_insta_email_content.png')} />
<Image
  width="30vw"
  style={{ maxHeight: '100%', maxWidth: '100%' }}
  src={require('file-loader!./images/10_insta_confirm_email.png')} />
</div>

---

# _"When" "Then"_ flows through the system
# Happy path integration?

[IMAGE?]

---

# Hey but there was a Given!

* what was the Given? (Arranged state)

<Notes>
  <ul>
    <li>GIVEN instagram has users</li>
    <li>AND users are promoted to be followed</li>
    <li>For this we will use a CONTEXT</li>
  </ul>
</Notes>

---

# let's bring back the Given

as a context
- context a user is signed up to insagram following 3 users

---

* **Context** instagram has users
* **And** some users are promoted to be recommended to be followed
* **When** User of the internet visits instagram for a first time
* **Then** ...

---

# Why not do each of these actions as Given, When, Then?

[core concpets!!!]

---

# Your turn

- explore?
- like?
- stories?
- profile?

---

# A demo app

<iframe frameborder="0" width="1400" height="600" src="http://localhost:3000/"></iframe>

- what is the flow?
- what could be the mechanics?

---

# Your turn

- write a flow for a user wants to play and needs a profile

---

# Let's take a look

_code dive_

<Notes>
<ul>
<li>straight out rspec</li>
<li>add when then steps</li>
<li>pull out page fragments</li>
</ul>
</Notes>

---

# Module 1 Review
## When Then steps

* mutlipe When Then actions add up to a flow
* gem `rspec-example_steps` helps organise `RSpec` tests
* _Key things that this will catch_
* _How to organise scenarios_

---

# Module 2
## Page Fragments

---

# What is a page fragment?

<Notes>
  <ul>
    <li>Often referred to as a page model</li>
    <li>A selenium test suite with capybara running the browser operates by executing browser actions written in code</li>
    <li>These actions are required to run the tests but they’re not important to the tests themselves</li>
    <li>And as tests act as a way for documenting behaviours of a system, you want to avoid convolution</li>
  </ul>
</Notes>

---

# What is a page fragment?

- Actions which are required to run the tests

<Notes>
  <ul>
    <li></li>
  </ul>
</Notes>

---

# Why are they useful?

<Notes>
  <ul>
    <li>Hiding away these actions into what we’ve come to know as page fragments helps keep tests cleaner, more readable and less fragile to change in the future</li>
  </ul>
</Notes>

---

# Why are they useful?

- Readable tests
- Less fragile to change

<Notes>
  <ul>
    <li>Hiding away these actions into what we’ve come to know as page fragments helps keep tests cleaner, more readable and less fragile to change in the future</li>
    <li>Changing text on element identified by className or data-attribute means your tests don’t break</li>
    <li>Changing className on an element means you only make an update to one fragment method in one place and all your tests still pass</li>
  </ul>
</Notes>

---

# Where do they belong in your code base?

- cd /bdd-workshop-app
- mkdir spec/support/features

<Notes>
  <ul>
    <li>along with the rest of your test suite, it makes sense to keep them under spec directory. And as supporting materials for feature tests, you might expect to find them in a similarly named directory</li>
    <li>let's create a new directory called spec/support/features</li>
  </ul>
</Notes>

---

# How are they available in tests?

```ruby
module PageFragments
  Page = Struct.new :rspec_example do
    alias_method :browser, :rspec_example # Capybara DSL + rspec example context
  end

  module DelegateSynchronize
    def synchronize(*selector_args, &block)
      page.document.synchronize(*selector_args, &block)
    end
  end

  def classify(string)
    string.to_s.split('_').map(&:capitalize).join
  end

  def focus_on(*args)
    require File.join(__dir__, 'page_fragments', args.map(&:to_s))
    mod = args.inject(PageFragments) do |klass, sub_klass|
      klass.const_get(classify(sub_klass))
    end
    page = Page.new(self).extend(mod)
    page.browser.extend(DelegateSynchronize)
    yield page if block_given?
    page
  end
end
```

<Notes>
  <ul>
    <li>module PageFragments included in rspec.config</li>
    <li>config.include PageFragments, type: :feature</li>
  </ul>
</Notes>

---

# How are they available in tests?

- browser methods

<Notes>
  <ul>
    <li>Where do the browser methods come from?</li>
    <li>#TODO</li>
  </ul>
</Notes>

---

# Your turn!

- visit website
- Find elements in the browser

<Notes>
  <ul>
    <li>(exercise)</li>
    <li>Let try an example using dev tools</li>
    <li>open the browser</li>
    <li>go to this website</li>
    <li>open dev tools</li>
    <li>#TODO example</li>
    <li>#TODO need to understand a little bit about html element hierarchy?</li>
  </ul>
</Notes>

---

# Construct fragment methods

- Find specific elements
- Pseudo construct fragment methods for those elements
    - How to write them
    - How to use them

<Notes>
  <ul>
    <li>(example)</li>
    <li>Ok, so now we understand the idea of page fragments</li>
    <li>And we know how to identify elements using browser methods</li>
    <li>Now, we need to understand how to write and use them</li>
    <li>#TODO example</li>
  </ul>
</Notes>

---

# Construct fragment methods

- Your turn!
- Find specific elements
- Pseudo construct fragment methods for those elements

<Notes>
  <ul>
    <li>(exercise)</li>
    <li>Now, let's see if we can write some page fragments</li>
  </ul>
</Notes>

---

# Making assertions

- Synchronise method
- has_no_css
- to_not be_present

<Notes>
  <ul>
    <li>(presentation)</li>
    <li>Synchronise method</li>
    <li>has_no_css</li>
    <li>to_not be_present</li>
  </ul>
</Notes>

---

# Now let's do it for real!

- Hide away basic fragments

<Notes>
  <ul>
    <li>Our app (exercise)</li>
    <li>convert monster file methods to fragments</li>
    <li>#TODO run through first example</li>
    <li>allow everyone to have a go</li>
  </ul>
</Notes>

---

# OO Design patterns

- Re-usability

<Notes>
  <ul>
    <li>(presentation)</li>
    <li>What does re-usability mean</li>
    <li>Why is re-usability important</li>
  </ul>
</Notes>

---

# OO Design patterns

- Patterns of reusable fragments

<Notes>
  <ul>
    <li>(presentation)</li>
    <li>Patterns of reusable fragments</li>
  </ul>
</Notes>

---

# Abstract reusable fragments

- Identifying generic elements
- Abstract reusable methods
- #TODO example goes here

<Notes>
  <ul>
    <li>(example)</li>
    <li>#TODO run through example</li>
  </ul>
</Notes>

---

# Benefits of page fragments

- Readable tests
- Hide away actions required to run tests but which aren't important to the tests themselves!
- Less fragile to change
- Reduced duplication

<Notes>
  <ul>
    <li>(example)</li>
    <li>Changing text on element identified by className or data-attribute means your tests don’t break</li>
    <li>Changing className on an element means you only make an update to one fragment method in one place and all your tests still pass</li>
  </ul>
</Notes>

---

# Summary

- #TODO

<Notes>
  <ul>
    <li>#TODO</li>
  </ul>
</Notes>

---

# Module 3
## Flows and Mechanics

<Notes>
  <ul>
    <li>Flows and mechanics are all just integration tests</li>
  </ul>
</Notes>

---

# Why do we define the split

- A way to organise your tests
- Avoid combinatorial explosion
- Easier to find specific tests for future modification
- Document how system works

---

# Flows

- Flows encapsulate behaviours from the UI, any Components involved, the API and all that rubbish in the backend, right down to the database layer.
- They test user and system flows through the app and their follow on effects, much like we did today.
    - #TODO Example of flow

---

# Mechanics

- Component with enough complexity will have their own mechanics test suite, basically to help with the organisation of the spaghetti your integration tests have the potential to quickly become.
- Mechanics typically do not have any “flow on” effects so they won’t be covered by the “flow”. These often allow us to integrate in isolation with a component which is a part of the page.
- #TODO Example of mechanic

---

# Defining which test belongs where

- Rules of flows

---

# Defining which test belongs where

- Rules of mechanics

---

# Your turn!

- Instagram - White board example of cuts through the app
- Organise example flows
- Organise example mechanics

---

# Let's see it in action!

- Our app see existing flows & mechanics
- White board example of cuts through the app
- Move scenarios from monster file into appropriate flows and mechanics

---

# SLIDE FROM MM outside in

_layered like an onion_

* UI Flows
  * core business
* Page mechanics
  * possible interactions with a page
* Frontend Component Tests
* API Integration
* service layer tests
* Controller Unit
* Domain logic

<Notes>
  <ul>
    <li>Flows multi step with flow on effects</li>
    <li>Mechanics possible interactions expected and unexpected</li>
    <li>all are unit tests, boundary of units</li>
    <li>Key is an organisation of tests</li>
    <li>UI flow should describe a system</li>
  </ul>
</Notes>

---

# MM from when then Other flows?

- what if username is taken?
- what happens if you turn notifications on?
- what if you do not follow anyone?

---

# MM from when/then Other tests?

- form not filled in?
- password too weak?
- don't follow anyone?
- notification modal yes/no?

---

# MM from when/then What about more detail

- email invalid
- forgot to enter madatory fields
- got an error in submission
- username suggest not working

* NOT IN FLOW - Next layer down
- split into page mechanics

---

# MM from when/then And even more detail

- reusable form compnents?
- validation on length of handle
- valid characters for handle
- spinners and loading effects

* NOT IN FLOW - Another layer down
- "unit" tests

---

# Module 4
## Flakys

---

# Module 5
## Drive new functionality through all the layers

---

# Module 6
## How your tests will fail with refactors

---

<https://github.com/failure-driven/bdd-workshop-app>

